cmdhistory=["(hof '(lambda (x) (println x)))" "(hof (lambda (x) (println x)))" "(hof '(lambda (x) (println x)))" "((lambda (a b c) (+ a b c)) 1 4 3)" "((fn (a b c) (+ a b c)) 1 4 3)" "((fn [a b c] (+ a b c)) 1 4 3)" "(hof '(fn [x] (println x)))" "(hof (fn [x] (println x)))" "((fn [&x] (println (length x))) 1 2)" "(fn [&x] (println (length x)))" "(fn [&x] (println x))" "(fn [&x] (println (count x)))" "(fn [& x] (println (count x)))" "((fn [&x] (println (count x))) 1 2)" "((fn [& x] (println (count x))) 1 2)" "((fn [x]\\n   (cond\\n     (> 1) (println true)\\n     (> 0) (println false)\\n     )\\n   ) 1)" "((fn [x] (cond (> 1) (println true) (> 0) (println false) ) ) 0)" "((fn [x] (cond (> 1) (println true) (> 0) (println false) ) ) 2)" "((fn [x] (cond (> 10) (println true) (> 0) (println false) ) ) 2)" "((fn [x] (cond (> 10) (println true) (> 0) (println false) ) ) 0)" "((fn [x] (cond ((> 10) (println true)) ((> 0) (println false)) ) ) 0)" "((fn [x] (cond ((> 10)(println true))((> 0) (println false))) ) 1)" "((fn [x] (cond ((> x 10)(println true))((> x 0) (println false))) ) 1)" "(fn [x] (cond ((> x 10)(println true))((> x 0) (println false))))" "((fn [x] (cond ((> x 10)(println true))((> x 0) (println false))) ) 1)" "(cond (> 10) (println true) (> 0) (println false) )" "(> 10)" "(< 10)" "(> 15 10)" "(> 10 15)" "((fn [x] (cond (> x 10)(println true)(> x 0) (println false)) ) 1)" "((fn [x] (cond (> x 10)(println true)(> x 0) (println false)) ) 13)" "exit" "(exit)" "exit" "(-> 1 2)" "(defn __[arg] (str \\"Hello, \\" arg \\"\!\\"))" "(\= (__ \\"Dave\\") \\"Hello, Dave\!\\")" "(\= (__ \\"Jenn\\") \\"Hello, Jenn\!\\")" "(\= (__ \\"Rhea\\") \\"Hello, Rhea\!\\")" "((fn [& args] (max args)) 1 2 3)" "((fn [& args] (type args)) 1 2 3)" "((fn [& args] (type 'args)) 1 2 3)" "((fn [& args] (max 'args)) 1 2 3)" "((fn [& args] (type args)) 1 2 3)" "((fn [& args]\\n   (loop[i 0 max 0]\\n     (cond\\n       (< i (count args))\\n       (recur (inc i)\\n              (cond\\n                (< max (args i))(args i)(max)))))\\n   1 2 3))" "((fn [& args]\\r\\n      (args 0)\\r\\n      1 2 3))" "((fn [& args] (aget args 0) 1 2 3))" "((fn [& args] (get args 0) 1 2 3))" "((fn [& args]\\r\\n      (loop[i 0 max 0]\\r\\n        (cond\\r\\n          (< i (count args))\\r\\n          (recur (inc i)\\r\\n                 (cond\\r\\n                   (< max (get args i))(get args i)(max)))))\\r\\n      1 2 3))" "((fn [& args] (+ args) 1 2 3))" "((fn [& args] (+ args) 5 2 3))" "((fn [& args] (max args) 5 2 3))" "((fn [& args] (max args) 5 2 3 1))" "((fn [& args] (max 'args) 5 2 3 1))" "((fn [& args] (max 'args) 5))" "((fn [& args]\\r\\n         (loop[i 0 max 0]\\r\\n           (cond\\r\\n             (< i (count args))\\r\\n             (recur (inc i)\\r\\n                    (cond\\r\\n                      (< max (get args i))(get args i)(max)))))\\r\\n         1 2 3))" "((fn [& args]\\r\\n         (loop[i 0 max 0]\\r\\n           (cond\\r\\n             (< i (count args))\\r\\n             (recur (inc i) max)))\\r\\n         1 7 3))" "((fn [& args]\\r\\n            (loop[max 0 i 0]\\r\\n              (cond\\r\\n                (< i (count args))\\r\\n                (recur (cond\\r\\n                         (< max (get args i))(get args i)(max))(inc i))))\\r\\n            1 7 3))" "((fn [& args]\\r\\n   (loop[max 0 i 0]\\r\\n     (cond\\r\\n       (< i (count args))\\r\\n       (recur (if (< max (get args i))(get args i)(max))(inc i))))\\r\\n   1 7 3))" "((fn [& args]\\r\\n   (loop[max 0 i 0]\\n     (let[cur (get args i)]\\r\\n       (cond\\r\\n         (< i (count args)(println (get args i)))\\r\\n         (recur (if (< max cur) cur max)(inc i)))))\\r\\n   1 7 3))" "((fn [& args]\\r\\n   (loop[max 0 i 0]\\r\\n     (let[cur (get args i)]\\n       (println max)\\r\\n       (println cur)\\r\\n       (println (< max cur))\\r\\n       (cond\\r\\n         (< i (count args)(println (get args i)))\\r\\n         (recur (if (< max cur) cur max)(inc i)))))\\r\\n   1 7 3))" "((fn [& args]\\r\\n      (loop[max 0 i 0]\\r\\n          (println i)\\r\\n          (println (get args i))\\r\\n        (let[cur (get args i)]\\r\\n          (println max)\\r\\n          (println cur)\\r\\n          (println (< max cur))\\r\\n          (cond\\r\\n            (< i (count args)(println (get args i)))\\r\\n            (recur (if (< max cur) cur max)(inc i)))))\\r\\n      1 7 3))" "((fn [& args]\\r\\n         (loop[max 0 i 0]\\r\\n             (println (get args 0))\\r\\n           (let[cur (get args i)]\\r\\n             (println max)\\r\\n             (println cur)\\r\\n             (println (< max cur))\\r\\n             (cond\\r\\n               (< i (count args)(println (get args i)))\\r\\n               (recur (if (< max cur) cur max)(inc i)))))\\r\\n         1 7 3))" "((fn [& args]\\r\\n            (loop[max 0 i 0]\\r\\n                (println args)\\r\\n              (let[cur (get args i)]\\r\\n                (println max)\\r\\n                (println cur)\\r\\n                (println (< max cur))\\r\\n                (cond\\r\\n                  (< i (count args)(println (get args i)))\\r\\n                  (recur (if (< max cur) cur max)(inc i)))))\\r\\n            1 7 3))" "((fn [& args]\\n   (println (get args i))\\r\\n   (loop[max 0 i 0]\\r\\n     (let[cur (get args i)]\\r\\n       (println max)\\r\\n       (println cur)\\r\\n       (println (< max cur))\\r\\n       (cond\\r\\n         (< i (count args)(println (get args i)))\\r\\n         (recur (if (< max cur) cur max)(inc i)))))\\r\\n   1 7 3))" "((fn [& args]\\r\\n      (println (get args 0))\\r\\n      (loop[max 0 i 0]\\r\\n        (let[cur (get args i)]\\r\\n          (println max)\\r\\n          (println cur)\\r\\n          (println (< max cur))\\r\\n          (cond\\r\\n            (< i (count args)(println (get args i)))\\r\\n            (recur (if (< max cur) cur max)(inc i)))))\\r\\n      1 7 3))" "((fn [& args](get args 0)))" "((fn [& args](get args 0)) 1 4 2 5)" "((fn [& args](args)) 1 4 2 5)" "((fn [& args](type args)) 1 4 2 5)" "((fn [& args](type 'args)) 1 4 2 5)" "(max [1 4 6 2 3])" "(max '[1 4 6 2 3])" "(max 1 4 6 2 3)" "(sum [1 4 6 2 3])" "((fn [& args](get args 0)\\r\\n   1 7 3))" "((fn [& args](get args 0) 1 7 3))" "((fn [& args](get args 1) 1 7 3))" "((fn [& args](get args 2) 1 7 3))" "((fn [& args](get args 3) 1 7 3))" "(conj '(3 4) 2 1)" "(fn (1 2 3 4))" "(fn [](1 2 3 4))" "(fn []('(1 2 3 4)))" "(defn [](1 2 3 4))" "(fn []'(1 2 3 4))" "(type (1 2 3 4))" "(type '(1 2 3 4))" "(list (1 2 3 4))" "(list* 1 2 3 4)" "(list* [1 2 3 4])" "(type (list* [1 2 3 4]))" "(PersistentList* [1 2 3 4])" "(fn [](1 2 3 4))" "((fn [](1 2 3 4)) 1 2 3 4)" "(type (fn [](1 2 3 4)))" "(type (fn [&](1 2 3 4)) 1)" "(type (fn [& args](1 2 3 4)) 1)" "((fn [& args](1 2 3 4)) 1)" "((fn [](1 2 3 4)))" "(fn [](1 2 3 4))" "((fn [](1 2 3 4)))" "(fn __[](1 2 3 4))" "(__)" "(__ 1)" "(fn xx[](1 2 3 4))" "(xx)" "(clear)" "(x)" "(fn [](1))" "(type (conj '(3 4) 2 1))" "(type (1 2 3 4))" "(defn func[x] (x \\"Hello, World\!\\"))\\r\\n(func (lambda [x] (println x)))" "(func (lambda [x] (println x)))" "(def \\r\\n ^{\:doc \\"Same as (def name (fn [params* ] exprs*)) or (def\\r\\n    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added\\r\\n    to the var metadata. prepost-map defines a map with optional keys\\r\\n    \:pre and \:post that contain collections of pre or post conditions.\\"\\r\\n   \:arglists '([name doc-string? attr-map? [params*] prepost-map? body]\\r\\n                [name doc-string? attr-map? ([params*] prepost-map? body)+ attr-map?])\\r\\n   \:added \\"1.0\\"}\\r\\n lambda (fn lambda [&form &env name & fdecl]\\r\\n        ;; Note\: Cannot delegate this check to def because of the call to (with-meta name ..)\\r\\n          (if (instance? clojure.lang.Symbol name)\\r\\n          nil\\r\\n          (throw (IllegalArgumentException. \\"First argument to lambda must be a symbol\\")))\\r\\n        (let [m (if (string? (first fdecl))\\r\\n                  {\:doc (first fdecl)}\\r\\n                  {})\\r\\n              fdecl (if (string? (first fdecl))\\r\\n                      (next fdecl)\\r\\n                      fdecl)\\r\\n              m (if (map? (first fdecl))\\r\\n                  (conj m (first fdecl))\\r\\n                  m)\\r\\n              fdecl (if (map? (first fdecl))\\r\\n                      (next fdecl)\\r\\n                      fdecl)\\r\\n              fdecl (if (vector? (first fdecl))\\r\\n                      (list fdecl)\\r\\n                      fdecl)\\r\\n              m (if (map? (last fdecl))\\r\\n                  (conj m (last fdecl))\\r\\n                  m)\\r\\n              fdecl (if (map? (last fdecl))\\r\\n                      (butlast fdecl)\\r\\n                      fdecl)\\r\\n              m (conj {\:arglists (list 'quote (sigs fdecl))} m)\\r\\n              m (let [inline (\:inline m)\\r\\n                      ifn (first inline)\\r\\n                      iname (second inline)]\\r\\n                  ;; same as\: (if (and (\= 'fn ifn) (not (symbol? iname))) ...)\\r\\n                    (if (if (clojure.lang.Util/equiv 'fn ifn)\\r\\n                        (if (instance? clojure.lang.Symbol iname) false true))\\r\\n                    ;; inserts the same fn name to the inline fn if it does not have one\\r\\n                      (assoc m \:inline (cons ifn (cons (clojure.lang.Symbol/intern (.concat (.getName ^clojure.lang.Symbol name) \\"__inliner\\"))\\r\\n                                                     (next inline))))\\r\\n                    m))\\r\\n              m (conj (if (meta name) (meta name) {}) m)]\\r\\n          (list 'def (with-meta name m)\\r\\n                ;;todo - restore propagation of fn name\\r\\n                  ;;must figure out how to convey primitive hints to self calls first\\r\\n\\t\\t\\t\\t\\t     ;;(cons `fn fdecl)\\r\\n\\t\\t\\t\\t\\t     (with-meta (cons `fn fdecl) {\:rettag (\:tag m)})))))" "(func (fn [x] (println x)))" "(reduce [1 2 3 4 5])" "(let [x (curring 1) y (x 2)] (println y))" "((fn [x] println x) \\"Lambda\\")" "(reduce + [1 2 3 4 5])" "(println (take 10 (iterate inc 1)))" "(println (take 10 (iterate inc 2)))" "(println (take 10 1))" "(println (take 10 (iterate 1)))" "(println (take 10 (iterate inc 12)))" "(^ 3 3)" "(** 3 3)" "(power 3 3)" "(sqrt 3 3)" "(Math/sqrt 9 2)" "(Math/sqrt 9\\n           )" "(Math/power 9)" "(Math/pow 9)" "(Math/sqrt 1)" "(Math/oow 3 2)" "(reduce + [1 2 3 4 5])" "(let [x (curring 3) y (x 2)] (println y))" "(* x y)" "(* 2 3)" "(Math/pow 1 2)" "(Math/pow 2 3)" "(Math/pow 3 3)" "(Math/pow 2 8)" "(Math/pow 2 9)" "(defn curring[x] (fn n[y](Math/pow x y)))\\r\\n(let [x (curring 2) y (x 8)] (println y))" "(defn curring[x] (fn [y] (Math/pow x y)))\\r\\n(let [x (curring 2) y (x 8)] (println y))" "((fn [x] println x) \\"Closure\\")" "(defn lambda[x] x \\"Lambda\\")\\r\\n(lambda (fn [x] println x))" "(defn curring[x] (fn [y] Math/pow x y))\\r\\n(let [x (curring 2) y (x 8)] println y)" "(defn curring[x] fn [y] (Math/pow x y))\\r\\n(let [x (curring 2) y (x 8)] (println y))" "((fn [x] println x) (defn lambda[x] x \\"Lambda\\"))" "((defn [x] println x) \\"Closure\\")" "(defn curring[x] (fn [y] (Math/pow x y)))\\r\\n(let [x (curring 2) y (x 8)] println y)" "((fn [& x] (reduct + x)) 1 2 3 4 5)" "((fn [& x] (reduce + x)) 1 2 3 4 5)" "((fn [& x] \\"Closure\\" (reduce + x)) 1 2 3 4 5)" "\\r\\n((fn [& x] \\"Closure\\" (reduce + (odd? x))) 1 2 3 4 5)" "((fn [& x] \\"Closure\\" (reduce * x)) 1 2 3 4 5)" "((fn [& x] \\"Closure\\" (reduce / x)) 1 2 3 4 5)" "((fn [& x] \\"Closure\\" (reduce / x)) 5 3)" "((fn [& x] \\"Closure\\" (reduce * x)) 2 5)" "((fn [& x] \\"Closure\\" (reduce * x)) 2 8)" "((fn [& x] \\"Closure\\" (reduce * (filter odd? x))) 2 8)" "((fn [& x] \\"Closure\\" (reduce * (filter odd? x))) 1 2 3 4 5)" "((fn [& x] \\"Closure\\" (reduce * (filter even? x))) 1 2 3 4 5)" "((fn [& x] \\"Closure\\" (reduce * (filter even? int? x))) 1 2 3 4 5)" "((fn [& x] \\"Closure\\" (reduce * (filter even? Integer? x))) 1 2 3 4 5)" "((fn [& x] \\"Closure\\" (reduce * (filter \\n                                 int? x))) 1 2 3 4 5)" "((fn [& x] \\"Closure\\" (reduce * (filter even? integer? x))) 1 2 3 4 5)" "((fn [& x] \\"Closure\\" (reduce * (filter even? (filter integer? x)))) 1 2 3 4 5)" "((fn [& x] \\"fusion\\"\\r\\n   (reduce * (filter even? (filter integer? x)))) 1 2 3 4 5)" "((fn [& x] \\"fusion\\"\\r\\n      (reduce * (filter even? (filter integer? x)))) 1 2 \\"3\\" 4 5)" "((fn [& x] \\"fusion\\"\\r\\n         (reduce * (filter even? (filter integer? x)))) 1 2 \\"3\\" \\"4\\" 5)" "((fn [& x]\\n   \\"fusion\\"\\n   (->\\n     x\\n     (filter integer?)\\n     (filter even?)\\n     (reduce *))) 1 2 \\"3\\" \\"4\\" 5)" "((fn [& x]\\r\\n      \\"fusion\\"\\r\\n      (->\\r\\n        x\\r\\n        (fn [y] (filter integer? y))\\r\\n        (fn [y] (filter even? y))\\r\\n        (fn [y] (reduce *)))) 1 2 \\"3\\" \\"4\\" 5)" "((fn [& x] \\"fusion\\"\\r\\n   (reduce * (filter even? (filter integer? x)))) 1 2 \\"3\\" \\"4\\" 5)" "((fn [& x] \\"fusion\\"\\r\\n      (reduce * (filter even? (filter integer? x)))) 1 2 \\"3\\" \\"4\\" 5 6)" "((fn [& x] \\"fusion\\"\\r\\n      (reduce * (filter even? (filter integer? x)))) 1 2 \\"3\\" 4 5)" "((fn [& x] \\"fusion\\"\\r\\n         (reduce * (filter even? x))) 1 2 \\"3\\" 4 5)" "((fn [& x] \\"fusion\\" (reduce * (filter even? filter integer? x))) 1 2 \\"3\\" \\"4\\" 5)" "((fn [& x] \\"fusion\\" (reduce * (filter even? (filter integer? x)))) 1 2 3 \\"4\\" 5)" "((fn [& x] \\"fusion\\" (filter integer? x)) 1 2 3 \\"4\\" 5)" "((fn [& x] \\"fusion\\" (filter even? (filter integer? x))) 1 2 3 \\"4\\" 5)" "((fn [& x] \\"fusion\\" \\n   (let[y (filter integer? x) z ((filter even? x))]\\n     (reduce * z))) 1 2 3 \\"4\\" 5)" "((fn [& x] \\"fusion\\" \\r\\n      (let [y (filter integer? x) z ((filter even? y))]\\r\\n        (reduce * z))) 1 2 3 \\"4\\" 5)" "((fn [& x] \\"fusion\\" \\r\\n   (let [y (filter integer? x)\\n         z (filter even? y)]\\r\\n     (reduce * z))) 1 2 3 \\"4\\" 5)" "(fn [o] (revese (.toCharArray o)) \\"this\\")" "(fn [o] (.toCharArray o) \\"this\\")" "(fn [o] (println (.toCharArray o)) \\"this\\")" "(reverse 1 2 3 4 5)" "(reverse [1 2 3 4 5])" "(fn [o] (str (.toCharArray o)) \\"this\\")" "(revese \\"this\\")" "(reverse \\"this\\")" "(fn [o] (str (reverse o)) \\"this\\")" "(fn [o] ((fn [n] (get o 0))(reverse o)) \\"this\\")" "(fn [o] ((fn [n] (println n))(reverse o)) \\"this\\")" "(fn [o] ((fn [n] (get n 0))(reverse o)) \\"this\\")" "(fn [o] ((fn [n] (type n))(reverse o)) \\"this\\")" "(reverse \\"this\\")" "(type (reverse \\"this\\"))" "(str (reverse \\"this\\"))" "(.toString (reverse \\"this\\"))" "((filter odd? (reverse \\"this\\")) (filter even? (reverse \\"this\\")))" "(filter odd? (reverse \\"this\\"))" "(filter odd? (take)(reverse \\"this\\"))" "(fn [o] (count o) \\"this\\")" "((fn [o] (count o)) \\"this\\")" "((fn [o] (take (count o) (iterator 1))) \\"this\\")" "((fn [o] (take (count o) )(iterator 1)) \\"this\\")" "(str [1 2 3])" "(map \#(* % %)(range))" "(map \#(* % %)(10))" "(map \#(* % %)(range 1 10))" "(take 10 (filter even? (map \#(* % %) (range))))" "(take 4)" "(take 4 (filter even?))" "((fn [o] (take-nth 2 (reverse o))) \\"this\\")" "((fn [o] (take-nth 2 (rest (reverse o)))) \\"this\\")" "((fn [o]\\n   (let [n (reverse o)\\n         f (fn [a] (take-nth 2 (a)))\\n         r (concat (f n) (f (rest n)))]\\n     (println r))) \\"this\\")" "((fn [o]\\r\\n      (let [n '(reverse o)\\r\\n            f (fn [a] (take-nth 2 (a)))\\r\\n            r (concat (f n) (f (rest n)))]\\r\\n        (println r))) \\"this\\")" "((fn [o]\\r\\n   (let [n (reverse o)\\r\\n         f (fn [a] (take-nth 2 a))\\r\\n         r (concat (f n) (f (rest n)))]\\r\\n     (println r))) \\"this\\")" "((fn [o]\\r\\n   (let [n (reverse o)\\r\\n         f (fn [a] (take-nth 2 a))\\r\\n         r (concat (f n) (f (rest n)))]\\r\\n     (map print r))) \\"this\\")" "((fn [o]\\r\\n   (let [n (reverse o)\\r\\n         f (fn [x] (take-nth 2 x))\\r\\n         r (concat (f n) (f (rest n)))]\\r\\n     (pr-str r))) \\"this\\")" "((fn [o]\\r\\n   (let [n (reverse o)\\r\\n         f (fn [x] (take-nth 2 x))\\r\\n         r (concat (f n) (f (rest n)))\\r\\n         s (str r)]\\r\\n     (println s))) \\"this\\")" "((fn [o]\\r\\n   (let [n (reverse o)\\r\\n         f (fn [x] (take-nth 2 x))\\r\\n         r (concat (f n) (f (rest n)))\\r\\n         s (str r)]\\r\\n     (println r))) \\"this\\")" "((fn [o]\\r\\n   (let [n (reverse o)\\r\\n         f (fn [x] (take-nth 2 x))\\r\\n         r (concat (f n) (f (rest n)))\\r\\n         s (str r)]\\r\\n     s)) \\"this\\")" "((fn [o]\\r\\n   (let [n (reverse o)\\r\\n         f (fn [x] (take-nth 2 x))\\r\\n         r (concat (f n) (f (rest n)))]\\r\\n     (count r))) \\"this\\")" "((fn [o]\\r\\n   (let [n (reverse o)\\r\\n         f (fn [x] (take-nth 2 x))\\r\\n         r (concat (f n) (f (rest n)))]\\r\\n     ((fn re[v] (print (first v))(if (\= v 0) (re (rest v))))) r)) \\"this\\")" "((fn [o]\\r\\n      (let [n (reverse o)\\r\\n            f (fn [x] (take-nth 2 x))\\r\\n            r (concat (f n) (f (rest n)))]\\r\\n        ((fn re[v] (print (first v))\\n           )) r)) \\"this\\")" "((fn [o]\\r\\n         (let [n (reverse o)\\r\\n               f (fn [x] (take-nth 2 x))\\r\\n               r (concat (f n) (f (rest n)))]\\r\\n           ((fn re[v] (print (first v))\\r\\n              )r))) \\"this\\")" "((fn [o]\\r\\n            (let [n (reverse o)\\r\\n                  f (fn [x] (take-nth 2 x))\\r\\n                  r (concat (f n) (f (rest n)))]\\r\\n              ((fn re[v] (print (first v)) (if (\= (count v) 0) (re (rest v)))\\r\\n                 )r))) \\"this\\")" "((fn [o]\\r\\n               (let [n (reverse o)\\r\\n                     f (fn [x] (take-nth 2 x))\\r\\n                     r (concat (f n) (f (rest n)))]\\r\\n                 ((fn re[v] (print (first v)) (if (not\= (count v) 0) (re (rest v)))\\r\\n                    )r))) \\"this\\")" "((fn [o]\\r\\n   (let [n (reverse o)\\r\\n         f (fn [x] (take-nth 2 x))\\r\\n         r (concat (f n) (f (rest n)))]\\r\\n     ((fn re[v] (cond (string?)((print (first v)) (re (rest v))))) r))) \\"this\\")" "((fn [o]\\r\\n      (let [n (reverse o)\\r\\n            f (fn [x] (take-nth 2 x))\\r\\n            r (concat (f n) (f (rest n)))]\\r\\n        ((fn re[v] (cond (string? v)((print (first v)) (re (rest v))))) r))) \\"this\\")" "((fn [o]\\r\\n   (let [n (reverse o)\\r\\n         f (fn [x] (take-nth 2 x))\\r\\n         r (concat (f n) (f (rest n)))]\\r\\n     ((fn re[v] (cond (string? (first v))((print (first v)) (re (rest v))))) r))) \\"this\\")" "((fn [o]\\r\\n   (let [n (reverse o)\\r\\n         f (fn [x] (take-nth 2 x))\\r\\n         r (concat (f n) (f (rest n)))]\\r\\n     ((fn re[v] (if (not\= (count v) 0) ((print (first v)) (re (rest v))))\\r\\n        )r))) \\"this\\")" "((fn [o]\\r\\n      (let [n (reverse o)\\r\\n            f (fn [x] (take-nth 2 x))\\r\\n            r (concat (f n) (f (rest n)))]\\r\\n        ((fn re[v] (if (not\= (count v) 0) ((print (first v)) (re (rest v))))\\r\\n           )r))) \\"this\\")" "((fn [o]\\r\\n         (let [n (reverse o)\\r\\n               f (fn [x] (take-nth 2 x))\\r\\n               r (concat (f n) (f (rest n)))]\\r\\n           ((fn re[v] (type v)(if (not\= (count v) 0) ((print (first v)) (re (rest v))))\\r\\n              )r))) \\"this\\")" "((fn [o]\\r\\n   (let [n (reverse o)\\r\\n         f (fn [x] (take-nth 2 x))\\r\\n         r (concat (f n) (f (rest n)))]\\r\\n     ((fn re[v]\\n        (println (type v))\\n        (if (not\= (count v) 0) ((print (first v)) (re (rest v))))\\r\\n        )r))) \\"this\\")" "((fn [o]\\r\\n      (let [n (reverse o)\\r\\n            f (fn [x] (take-nth 2 x))\\r\\n            r (concat (f n) (f (rest n)))]\\r\\n        ((fn re[v]\\r\\n           (println (not\= (count v) 0))\\r\\n           (if (not\= (count v) 0) ((print (first v)) (re (rest v))))\\r\\n           )r))) \\"this\\")" "((fn [o]\\r\\n         (let [n (reverse o)\\r\\n               f (fn [x] (take-nth 2 x))\\r\\n               r (concat (f n) (f (rest n)))]\\r\\n           ((fn re[v]\\r\\n              (println (not\= (count v) 0))\\r\\n              (cond (not\= (count v) 0)((print (first v))(re (rest v))))\\r\\n              )r))) \\"this\\")" "((fn [o]\\r\\n            (let [n (reverse o)\\r\\n                  f (fn [x] (take-nth 2 x))\\r\\n                  r (concat (f n) (f (rest n)))]\\r\\n              ((fn re[v]\\r\\n                 (println (not\= (count v) 0))\\r\\n                 (cond\\n                   ((not\= (count v) 0)((print (first v))(re (rest v)))))\\r\\n                 )r))) \\"this\\")" "((fn [o]\\r\\n               (let [n (reverse o)\\r\\n                     f (fn [x] (take-nth 2 x))\\r\\n                     r (concat (f n) (f (rest n)))]\\r\\n                 ((fn re[v]\\r\\n                    (println (not\= (count v) 0))\\r\\n                    (cond\\r\\n                      (not\= (count v) 0)((re (rest v))(print (first v))))\\r\\n                    )r))) \\"this\\")" "((fn [o]\\r\\n   (let [n (reverse o)\\r\\n         f (fn [x] (take-nth 2 x))\\r\\n         r (concat (f n) (f (rest n)))]\\r\\n     ((fn re[v]\\r\\n        (println (not\= (count v) 0))\\r\\n        (cond\\r\\n          (not\= (count v) 0)\\n          ((print (first v))\\n            (re (rest v)))\\n          )\\r\\n        )r))) \\"this\\")" "((fn [o](cond (o \=\= 2)(println 1))) 2)" "((fn [o](cond ((o \=\= 2)(println 1)))) 2)" "((fn [o](cond ((\= o 2)(println 1)))) 2)" "((fn [o](cond (\= o 2)(println 1))) 2)" "((fn [o](cond (\= o 2)(println 1))) 1)" "((fn [o](cond (\= o 2)((println 1)(println 2)))) 1)" "((fn [o](cond (\= o 2)((println 1)(println 2)))) 2)" "((fn [o]\\r\\n   (let [n (reverse o)\\r\\n         f (fn [x] (take-nth 2 x))\\r\\n         r (concat (f n) (f (rest n)))]\\r\\n     ((fn re[v]\\r\\n        (print (first v))\\r\\n        (cond\\r\\n          (> (count v) 0)(re (rest v)))\\r\\n        )r))) \\"this\\")" "((fn [o]\\r\\n      (let [n (reverse o)\\r\\n            f (fn [x] (take-nth 2 x))\\r\\n            r (concat (f n) (f (rest n)))]\\r\\n        ((fn re[v]\\r\\n           (print (first v))\\r\\n           (cond\\r\\n             (> (count v) 0)(re (rest v)))\\r\\n           )r))) \\"how\\")" "((fn [o]\\r\\n   (let [n (reverse o)\\r\\n         f (fn [x] (take-nth 2 x))\\r\\n         r (concat (f n) (f (rest n)))]\\r\\n     ((fn re[v]\\r\\n        (print (first v))\\r\\n        (cond\\r\\n          (> (count v) 1)(re (rest v)))\\r\\n        )r))) \\"this\\")" "((fn [o]\\r\\n   (let [n (reverse o)\\r\\n         f (fn [x] (take-nth 2 x))\\r\\n         r (concat (f n) (f (rest n)))]\\r\\n     ((fn re[v z] (str z (first v)) (cond (> 1 (count v))(re (rest v)) z)) r))\\r\\n   ) \\"this\\")" "((fn [o]\\r\\n      (let [n (reverse o)\\r\\n            f (fn [x] (take-nth 2 x))\\r\\n            r (concat (f n) (f (rest n)))]\\r\\n        ((fn re[v z]\\n           (str z\\n                (first v))\\n           (cond (> 1 (count v))\\n                 (re (rest v)) z)) r))\\r\\n      ) \\"this\\")" "((fn [o]\\r\\n         (let [n (reverse o)\\r\\n               f (fn [x] (take-nth 2 x))\\r\\n               r (concat (f n) (f (rest n)))]\\r\\n           ((fn re[v z]\\r\\n              (str z\\r\\n                   (first v))\\r\\n              (cond (> 1 (count v))\\r\\n                    (re (rest v)) z)) r \\"\\"))\\r\\n         ) \\"this\\")" "((fn [o]\\r\\n            (let [n (reverse o)\\r\\n                  f (fn [x] (take-nth 2 x))\\r\\n                  r (concat (f n) (f (rest n)))]\\r\\n              ((fn re[v z]\\r\\n                 (str z\\r\\n                      (first v))\\r\\n                 (cond (> 1 (count v))\\r\\n                       (re (rest v)) \:else z)) r \\"\\"))\\r\\n            ) \\"this\\")" "((fn [o]\\r\\n               (let [n (reverse o)\\r\\n                     f (fn [x] (take-nth 2 x))\\r\\n                     r (concat (f n) (f (rest n)))]\\r\\n                 ((fn re[v z]\\r\\n                    (str z\\r\\n                         (first v))\\r\\n                    (cond (> 1 (count v))\\r\\n                          (re (rest v)) \:else z)) r))\\r\\n               ) \\"this\\")" "((fn [o]\\r\\n   (let [n (reverse o)\\r\\n         f (fn [x] (take-nth 2 x))\\r\\n         r (concat (f n) (f (rest n)))]\\r\\n     ((fn re[v z]\\r\\n        (str z (first v))\\r\\n        (cond (> 1 (count v)) (re (rest v))\\n              \:else (println z))) r \\"\\"))\\r\\n   ) \\"this\\")" "((fn [o]\\r\\n      (let [n (reverse o)\\r\\n            f (fn [x] (take-nth 2 x))\\r\\n            r (concat (f n) (f (rest n)))]\\r\\n        ((fn re[v z]\\r\\n           \\r\\n           (cond (> 1 (count v)) (re (rest v) (str z (first v)))\\r\\n                 \:else (println z))) r \\"\\"))\\r\\n      ) \\"this\\")" "((fn [o]\\r\\n         (let [n (reverse o)\\r\\n               f (fn [x] (take-nth 2 x))\\r\\n               r (concat (f n) (f (rest n)))]\\r\\n           ((fn re[v z]\\r\\n              \\r\\n              (cond (> 1 (count v)) (re (rest v) (str z (first v)))\\r\\n                    \:else z)) r \\"\\"))\\r\\n         ) \\"this\\")" "<type clojure code here>((fn [o]\\r\\n   (let [n (reverse o)\\r\\n         f (fn [x] (take-nth 2 x))\\r\\n         r (concat (f n) (f (rest n)))]\\r\\n     ((fn re[v] (print (first v)) (cond (> 1 (count v))(re (rest v)))) r))\\r\\n   ) \\"this\\")" "((fn [o]\\r\\n   (let [n (reverse o)\\r\\n         f (fn [x] (take-nth 2 x))\\r\\n         r (concat (f n) (f (rest n)))]\\r\\n     ((fn re[v] (print (first v)) (cond (> 1 (count v))(re (rest v)))) r))\\r\\n   ) \\"this\\")" "((fn [o]\\r\\n   (let [n (reverse o)\\r\\n         f (fn [x] (take-nth 2 x))\\r\\n         r (concat (f n) (f (rest n)))]\\r\\n     ((fn re[v]\\r\\n        (print (first v))\\r\\n        (cond (> 1 (count v))(re (rest v)))) r))\\r\\n   ) \\"this\\")" "((fn [o]\\r\\n   (let [n (reverse o)\\r\\n         f (fn [x] (take-nth 2 x))\\r\\n         r (concat (f n) (f (rest n)))]\\r\\n     ((fn re[v]\\r\\n        (print (first v))\\r\\n        (cond (> (count v) 1)(re (rest v)))) r))\\r\\n   ) \\"this\\")" "((fn [o]\\r\\n   (let [n (reverse o)\\r\\n         f (fn [x] (take-nth 2 x))\\r\\n         r (concat (f n) (f (rest n)))]\\r\\n     ((fn re[v z] (cond (> (count v) 1)(re (rest v) (str z (first v))) \:else z)) r))\\r\\n   ) \\"this\\")" "((fn [o]\\r\\n      (let [n (reverse o)\\r\\n            f (fn [x] (take-nth 2 x))\\r\\n            r (concat (f n) (f (rest n)))]\\r\\n        ((fn re[v z] (cond (> (count v) 1)(re (rest v) (str z (first v))) \:else z)) r \\"\\"))\\r\\n      ) \\"this\\")" "((fn [o]\\r\\n         (let [n (reverse o)\\r\\n               f (fn [x] (take-nth 2 x))\\r\\n               r (concat (f n) (f (rest n)))]\\r\\n           ((fn re[v z] (cond (> (count v) 0)(re (rest v) (str z (first v))) \:else z)) r \\"\\"))\\r\\n         ) \\"this\\")" "((fn [o]\\r\\n   (let [n (reverse o)\\r\\n         f (fn [x] (take-nth 2 x))\\r\\n         r (concat (f n) (f (rest n)))]\\r\\n     ((fn re[v z] (cond (> (count v) 0)(re (rest v) (str z (first v)))) z) r \\"\\"))\\r\\n   ) \\"this\\")" "((fn [o]\\r\\n   (let [n (reverse o)\\r\\n         f (fn [x] (take-nth 2 x))\\r\\n         r (concat (f n) (f (rest n)))]\\r\\n     ((fn re[v z] (cond (> (count v) 0)(re (rest v) (str z (first v)))(true) z)) r \\"\\"))\\r\\n   ) \\"this\\")" "((fn [o]\\r\\n   (let [n (reverse o)\\r\\n         f (fn [x] (take-nth 2 x))\\r\\n         r (concat (f n) (f (rest n)))]\\r\\n     ((fn re[v z] (cond (> (count v) 0)(re (rest v) (str z (first v)))true z)) r \\"\\"))\\r\\n   ) \\"this\\")" "((fn [o]\\r\\n   (let [n (reverse o)\\r\\n         f (fn [x] (take-nth 2 x))\\r\\n         r (concat (f n) (f (rest n)))]\\r\\n     ((fn re[v z] (cond (> (count v) 0)(re (rest v) (str z (first v))) true z)) r \\"\\"))\\r\\n   ) \\"this\\")" "(reverse \\"1234\\")" "(str (reverse \\"1234\\"))" "(clojure.string/reverse \\"1234\\")" "(clojure.string/reverse (reverse \\"1234\\"))" "((fn [o]\\r\\n   (let [n (reverse o) f (fn [x] (take-nth 2 x)) r (concat (f n) (f (rest n)))]\\r\\n     ((fn re[v z] (cond (> (count v) 0)(re (rest v) (str z (first v))) true z)) r \\"\\"))\\r\\n   ) \\"shit\\")" "((fn [o]\\r\\n   (let [n (reverse o) f (fn [x] (take-nth 2 x)) r (concat (f n) (f (rest n)))]\\r\\n     ((fn re[v z] (cond (> (count v) 0)(re (rest v) (str z (first v))) true z)) r \\"\\"))\\r\\n   ) \\"who\\")" "(defn func[o]\\r\\n  (let [n (reverse o) f (fn [x] (take-nth 2 x)) r (concat (f n) (f (rest n)))]\\r\\n    ((fn re[v z] (cond (> (count v) 0)(re (rest v) (str z (first v))) true z)) r \\"\\")))" "(func \\"how\\")" "(func \\"are\\")" "(func \\"that\\")" "(func \\"this\\")" "(func \\"1234567890\\")" "((fn [o]\\r\\n   (let [n (reverse o) f (fn [x] (take-nth 3 x)) r (concat (f n) (f (rest (rest n))) (f (rest n)))]\\r\\n     ((fn re[v z] (cond (> (count v) 0)(re (rest v) (str z (first v))) true z)) r \\"\\"))\\r\\n   ) \\"15645155210\\")" "((fn [o]\\r\\n   (let [n (reverse o) f (fn [x] (take-nth 3 x)) r (concat (f n) (f (rest (rest n))) (f (rest n)))]\\r\\n     ((fn re[v z] (cond (> (count v) 0)(re (rest v) (str z (first v))) true z)) r \\"\\"))\\r\\n   ) \\"54056115251\\")" "((fn [o]\\r\\n      (let [n (reverse o) f (fn [x] (take-nth 3 x)) r (concat (f n) (f (rest (rest n))) (f (rest n)))]\\r\\n        ((fn re[v z] (cond (> (count v) 0)(re (rest v) (str z (first v))) true z)) r \\"\\"))\\r\\n      ) \\"04516125551\\")" "((fn [o]\\r\\n   (let [n (reverse o) f (fn [x] (take-nth 3 x)) r (concat (f (rest n)) (f (rest (rest n))) (f n))]\\r\\n     ((fn re [v z] (cond (> (count v) 0)(re (rest v) (str z (first v))) true z)) r \\"\\"))\\r\\n   ) \\"40561152515\\")" "((fn [o]\\r\\n   (let [n (reverse o)\\r\\n         f (fn [x] (take-nth 3 x))\\r\\n         r (concat (f (rest n)) (f (rest (rest n))) (f n))]\\r\\n     ((fn re [x y]\\r\\n        (cond (> (count x) 0)(re (rest x) (str y (first x))) true y)) r \\"\\"))\\r\\n   ) \\"40561152515\\")" "(->\\n  \\"1234\\"\\n  reverse)" "(->\\r\\n     \\"1234\\"\\r\\n     reverse\\n     take-nth 3)" "((fn [o]\\r\\n   (let [n (reverse o) f (fn [x] (take-nth 3 x)) v (rest n)\\r\\n         s (concat (f v) (f (rest v)) (f n))]\\r\\n     ((fn r [x y]\\r\\n        (cond (> (count x) 0)(r (rest x) (str y (first x))) true y)) s \\"\\"))\\r\\n   ) \\"40561152515\\")" "(->\\n  \\"40561152515\\"\\n  (fn [o]\\r\\n   (let [n (reverse o) v (rest n)\\r\\n         f (fn [x] (take-nth 3 x))\\r\\n         s (concat (f v) (f (rest v)) (f n))]\\n     s)\\r\\n   ))" "((fn [o]\\r\\n   (let [n (reverse o)\\r\\n         v (rest n)\\r\\n         f (fn [x] (take-nth 3 x))\\r\\n         s (concat (f v) (f (rest v)) (f n))]\\r\\n     ((fn r [x y]\\r\\n        (cond (> (count x) 0) (r (rest x) (str y (first x))) true y)) s \\"\\"))\\r\\n   ) \\"40561152515\\")" "((fn [o]\\r\\n   (let [n (reverse o)\\r\\n         v (rest n)\\r\\n         f (fn [x] (take-nth 3 x))\\r\\n         s (concat (f v) (f (rest v)) (f n))]\\r\\n     s)\\r\\n   ) \\"40561152515\\")" "\\r\\n(map \#(* % %)(range 1 10))" "((fn [o]\\r\\n   (let [n (reverse o)\\r\\n         v (rest n)\\r\\n         f (fn [x] (take-nth 3 x))\\r\\n         s (concat (f v) (f (rest v)) (f n))]\\r\\n     ((fn r [x y]\\r\\n        (cond\\r\\n          (> (count x) 0) (r (rest x) (str y (first x))) true y)\\r\\n        ) s \\"\\"))\\r\\n   ) \\"40561152515\\")"]
eclipse.preferences.version=1
